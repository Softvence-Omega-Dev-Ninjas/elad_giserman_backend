model Invoice {
  id String @id @default(uuid())

  invoiceNumber String @unique

  userSubscriptionId String
  userSubscription   UserSubscription @relation(fields: [userSubscriptionId], references: [id], onDelete: Cascade)

  stripeInvoiceId String? @unique

  // Simplified amounts - store only what matters
  amountCents Int // total amount due
  paidCents   Int    @default(0) // amount paid so far
  currency    String @default("usd")

  status      InvoiceStatus @default(DRAFT)
  periodStart DateTime
  periodEnd   DateTime
  dueDate     DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  @@index([userSubscriptionId])
  @@index([status])
  @@map("invoices")
}

enum InvoiceStatus {
  DRAFT // created but not sent/charged
  PAID // invoice fully paid
  UNPAID // invoice unpaid / past due
}
